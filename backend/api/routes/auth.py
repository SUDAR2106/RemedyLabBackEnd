#remedylab/backend/api/routes/signup.py

from fastapi import APIRouter, HTTPException, status
from datetime import datetime , timedelta,timezone # Import datetime for updating updated_at
import bcrypt # Import bcrypt for password verification
from jose import jwt # Import jwt for token generation
from config import jwt_secret, JWT_ALGORITHM ,JWT_EXP_DELTA_SECONDS # Import your JWT configuration

from api.schemas.auth import LoginRequest, LoginSuccessResponse
from models.user_model import User # Import your User model

router = APIRouter()

@router.post("/login", response_model=LoginSuccessResponse, summary="Authenticates a user with their username and password.")
async def login(request: LoginRequest):
    """
    Authenticates a user with their username and password.
    """
    # Validates if fields are empty.
    if not request.username or not request.password:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Please enter both username and password."
        )

    # Retrieves user by username from the database using User.get_by_username().
    user = User.get_by_username(request.username)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid username or password. Please try again."
        )

    # Verifies the provided password against the stored hashed password using bcrypt.checkpw().
    # Ensure the password_hash stored in your database is correctly generated by bcrypt.hashpw()
    # and decoded to bytes for comparison if stored as string.
    try:
        if not bcrypt.checkpw(request.password.encode('utf-8'), user.password_hash.encode('utf-8')):
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid username or password. Please try again."
            )
    except ValueError:
        # This can happen if password_hash is not a valid bcrypt hash
        print(f"Error: Stored password hash for user {user.username} is invalid.")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="An unexpected error occurred during authentication. (Invalid password hash)"
        )
    # JWT token payload

    payload = {
        "sub": user.username,
        "user_id": user.user_id,
        "user_type": user.user_type,
        "exp": datetime.now(timezone.utc) + timedelta(seconds=JWT_EXP_DELTA_SECONDS)
    }

    # Generate JWT
    access_token = jwt.encode(payload, jwt_secret, algorithm=JWT_ALGORITHM)

    # Updates updated_at timestamp for the user upon successful login.
    # Note: Your User class doesn't have an update method directly.
    # You might need to add a method to `User` class or directly use DBManager
    # For now, we'll simulate this if a direct update method isn't implemented.
    # If your DBManager allows direct execution and your User object holds a reference
    # to a db session, you could do: user.updated_at = datetime.now().isoformat() and save.
    # For `user_model.py`, you'd need to add an update method to the User class.
    # Example (add this to your User class in user_model.py):
    # def update_last_login(self):
    #     db_manager = DBManager()
    #     self.updated_at = datetime.now().isoformat()
    #     query = "UPDATE users SET updated_at = ? WHERE user_id = ?"
    #     return db_manager.execute_query(query, (self.updated_at, self.user_id))
    # Then call it here:
    # user.update_last_login()


    # GENERATE JWT TOKEN HERE
    # This is a placeholder. You need to implement your JWT generation logic.
    # Example using python-jose:
    # from jose import jwt
    # from backend.core.config import settings # Assuming you have a settings file with SECRET_KEY
    # access_token_expires = timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    # to_encode = {"sub": user.username, "user_id": user.user_id, "user_type": user.user_type}
    # access_token = create_access_token(to_encode, expires_delta=access_token_expires)
    # For now, a placeholder:
   # access_token = "your_generated_jwt_token_here" # REPLACE THIS WITH REAL JWT GENERATION

    # Sets Streamlit st.session_state variables for logged_in, user_id, user_type, username, first_name, last_name, email, and logged_in_user.
    # This is frontend (Streamlit) logic. The backend provides the data.

    # Navigates to a dashboard based on user_type (patient_dashboard, doctor_dashboard, admin_dashboard).
    # This is also frontend (Streamlit) navigation logic.

    return LoginSuccessResponse(
        message="Login successful",
        access_token=access_token,
        token_type="bearer",
        user_id=user.user_id,
        username=user.username,
        user_type=user.user_type,
        first_name=user.first_name,
        last_name=user.last_name,
        email=user.email
    )

    # The document also specifies a 500 Internal Server Error for "An unexpected error occurred."
    # This should ideally be caught by a broader exception handler or specific try-except blocks
    # around database operations or critical logic. For now, if code reaches here without a return,
    # it implies an unhandled error.