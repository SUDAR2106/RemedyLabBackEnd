#remedylab\backend\models\health_report_model.py

from pydantic import BaseModel, Field
from typing import Optional, Dict, Any, List
from datetime import datetime
import uuid
import json # To handle JSON string for extracted_data_json

from database.db_utils import DBManager # Import DBManager
# --- Health Report Models ---

class HealthReportBase(BaseModel):
    """
    Base Pydantic model for HealthReport, containing common fields.
    """
    patient_id: str = Field(..., example=str(uuid.uuid4()))
    uploaded_by: str = Field(..., example=str(uuid.uuid4())) # User ID of who uploaded
    report_type: Optional[str] = Field(None, max_length=100, example="Medical Report")
    file_type: Optional[str] = Field(None, max_length=20, example=".pdf")
    file_name: Optional[str] = Field(None, max_length=255, example="patient_A_report.pdf")
    # file_path will be generated by the backend, not provided by client
    # extracted_data_json will be populated later by data extraction service
    assigned_doctor_id: Optional[str] = Field(None, example=str(uuid.uuid4()))
    processing_status: str = Field("uploaded", example="uploaded") # Default status

class HealthReportCreate(HealthReportBase):
    """
    Pydantic model for creating a new HealthReport (input schema).
    Note: The actual file content will be handled separately in the FastAPI endpoint
    using UploadFile, not directly part of this Pydantic model's body.
    """
    pass # No additional fields beyond HealthReportBase for now

class HealthReportRead(HealthReportBase):
    """
    Pydantic model for reading HealthReport data (output schema).
    Includes fields generated by the database/backend.
    """
    report_id: str = Field(..., example=str(uuid.uuid4()))
    upload_date: datetime = Field(..., example=datetime.now())
    file_path: str = Field(..., example="/app/uploaded_files/unique_file_name.pdf") # The actual path on server
    extracted_data_json: Optional[str] = Field(None, example='{"symptoms": "fever", "diagnosis": "flu"}')

    class Config:
        from_attributes = True # Pydantic v2+ equivalent of orm_mode = True

# --- Database Interaction Class ---
class HealthReport:
    def __init__(self, report_id: str, patient_id: str, uploaded_by: str,
                 report_type: Optional[str], file_type: Optional[str],
                 upload_date: str, file_name: str, file_path: str,
                 extracted_data_json: Optional[str], assigned_doctor_id: Optional[str],
                 processing_status: str):
        self.report_id = report_id
        self.patient_id = patient_id
        self.uploaded_by = uploaded_by
        self.report_type = report_type
        self.file_type = file_type
        self.upload_date = upload_date # Stored as ISO format string
        self.file_name = file_name
        self.file_path = file_path
        self.extracted_data_json = extracted_data_json
        self.assigned_doctor_id = assigned_doctor_id
        self.processing_status = processing_status

    @classmethod
    def create(cls, patient_id: str, uploaded_by: str, report_type: Optional[str],
               file_type: Optional[str], file_name: str, file_path: str,
               extracted_data_json: Optional[str] = None, assigned_doctor_id: Optional[str] = None,
               processing_status: str = "uploaded") -> Optional['HealthReport']:
        report_id = str(uuid.uuid4())
        upload_date = datetime.now().isoformat()
        db_manager = DBManager()

        query = """
            INSERT INTO health_reports (report_id, patient_id, uploaded_by, report_type, file_type,
                                       upload_date, file_name, file_path, extracted_data_json,
                                       assigned_doctor_id, processing_status)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        """
        params = (report_id, patient_id, uploaded_by, report_type, file_type,
                  upload_date, file_name, file_path, extracted_data_json,
                  assigned_doctor_id, processing_status)

        if db_manager.execute_query(query, params):
            return cls(report_id, patient_id, uploaded_by, report_type, file_type,
                       upload_date, file_name, file_path, extracted_data_json,
                       assigned_doctor_id, processing_status)
        return None
    @classmethod
    def count_by_patient_id(cls, patient_id: str) -> int:
        """
        Count the total number of health reports for a specific patient.
        
        Args:
            patient_id (str): The patient ID to count reports for
            
        Returns:
            int: Number of reports for the patient
        """
        db_manager = DBManager()
        query = "SELECT COUNT(*) as count FROM health_reports WHERE patient_id = ?"
        result = db_manager.fetch_one(query, (patient_id,))
        return result['count'] if result else 0

    @classmethod
    def get_latest_by_patient_id(cls, patient_id: str) -> Optional['HealthReport']:
        """
        Get the most recent health report for a specific patient based on upload_date.
        
        Args:
            patient_id (str): The patient ID to get the latest report for
            
        Returns:
            Optional[HealthReport]: The most recent HealthReport object or None if no reports found
        """
        db_manager = DBManager()
        query = """
            SELECT * FROM health_reports 
            WHERE patient_id = ? 
            ORDER BY upload_date DESC 
            LIMIT 1
        """
        result = db_manager.fetch_one(query, (patient_id,))
        if result:
            return cls(**result)
        return None

    @classmethod
    def get_by_patient_id_paginated(cls, patient_id: str, skip: int = 0, limit: int = 100) -> List['HealthReport']:
        """
        Get paginated health reports for a specific patient, ordered by upload_date (most recent first).
        
        Args:
            patient_id (str): The patient ID to get reports for
            skip (int): Number of records to skip (for pagination)
            limit (int): Maximum number of records to return
            
        Returns:
            List[HealthReport]: List of HealthReport objects
        """
        db_manager = DBManager()
        query = """
            SELECT * FROM health_reports 
            WHERE patient_id = ? 
            ORDER BY upload_date DESC 
            LIMIT ? OFFSET ?
        """
        results = db_manager.fetch_all(query, (patient_id, limit, skip))
        return [cls(**result) for result in results] if results else []

    @classmethod
    def get_by_patient_id(cls, patient_id: str) -> List['HealthReport']:
        """
        Get all health reports for a specific patient, ordered by upload_date (most recent first).
        
        Args:
            patient_id (str): The patient ID to get reports for
            
        Returns:
            List[HealthReport]: List of HealthReport objects
        """
        db_manager = DBManager()
        query = """
            SELECT * FROM health_reports 
            WHERE patient_id = ? 
            ORDER BY upload_date DESC
        """
        results = db_manager.fetch_all(query, (patient_id,))
        return [cls(**result) for result in results] if results else []
    @classmethod
    def get_by_report_id(cls, report_id: str) -> Optional['HealthReport']:
        db_manager = DBManager()
        query = "SELECT * FROM health_reports WHERE report_id = ?"
        result = db_manager.fetch_one(query, (report_id,))
        if result:
            return cls(**result)
        return None

    def save(self) -> bool:
        """Saves the current state of the HealthReport object back to the database."""
        db_manager = DBManager()
        query = """
            UPDATE health_reports SET
                patient_id = ?, uploaded_by = ?, report_type = ?, file_type = ?,
                upload_date = ?, file_name = ?, file_path = ?, extracted_data_json = ?,
                assigned_doctor_id = ?, processing_status = ?
            WHERE report_id = ?
        """
        params = (self.patient_id, self.uploaded_by, self.report_type, self.file_type,
                  self.upload_date, self.file_name, self.file_path, self.extracted_data_json,
                  self.assigned_doctor_id, self.processing_status, self.report_id)
        return db_manager.execute_query(query, params)

    def update_processing_status(self, new_status: str) -> bool:
        self.processing_status = new_status
        return self.save()

    def update_assigned_doctor(self, doctor_id: str) -> bool:
        self.assigned_doctor_id = doctor_id
        self.processing_status = "assigned_to_doctor" # Or 'pending_doctor_review' as per your flow
        return self.save()

    def to_dict(self) -> Dict[str, Any]:
        """Converts the HealthReport object to a dictionary."""
        return {
            "report_id": self.report_id,
            "patient_id": self.patient_id,
            "uploaded_by": self.uploaded_by,
            "report_type": self.report_type,
            "file_type": self.file_type,
            "upload_date": self.upload_date,
            "file_name": self.file_name,
            "file_path": self.file_path,
            "extracted_data_json": self.extracted_data_json,
            "assigned_doctor_id": self.assigned_doctor_id,
            "processing_status": self.processing_status
        }